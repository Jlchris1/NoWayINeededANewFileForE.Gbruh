-- Gui to Lua
-- Version: 3.2

-- Instances:

local elementalgroundsgui = Instance.new("ScreenGui")
local mainframe = Instance.new("Frame")
local autofarmsetuptab = Instance.new("TextButton")
local AFV2tab = Instance.new("Frame")
local instantautofarmv2mobile = Instance.new("TextButton")
local TextLabel = Instance.new("TextLabel")
local instantautofarmv2laptop = Instance.new("TextButton")
local autofarmcollectables = Instance.new("TextButton")
local toggle = Instance.new("TextButton")

--Properties:

elementalgroundsgui.Name = "elemental grounds gui"
elementalgroundsgui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
elementalgroundsgui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

mainframe.Name = "main frame"
mainframe.Parent = elementalgroundsgui
mainframe.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mainframe.BorderColor3 = Color3.fromRGB(255, 0, 0)
mainframe.BorderSizePixel = 0
mainframe.Position = UDim2.new(0.34368366, 0, 0.229766801, 0)
mainframe.Size = UDim2.new(0, 399, 0, 239)

autofarmsetuptab.Name = "auto farm setup tab"
autofarmsetuptab.Parent = mainframe
autofarmsetuptab.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
autofarmsetuptab.BorderColor3 = Color3.fromRGB(0, 0, 0)
autofarmsetuptab.BorderSizePixel = 0
autofarmsetuptab.Size = UDim2.new(0, 101, 0, 50)
autofarmsetuptab.Font = Enum.Font.SourceSansBold
autofarmsetuptab.Text = "AF V2 setup"
autofarmsetuptab.TextColor3 = Color3.fromRGB(0, 0, 0)
autofarmsetuptab.TextSize = 17.000

AFV2tab.Name = "AF V2 tab"
AFV2tab.Parent = mainframe
AFV2tab.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
AFV2tab.BorderColor3 = Color3.fromRGB(0, 0, 0)
AFV2tab.BorderSizePixel = 0
AFV2tab.Position = UDim2.new(0.25313282, 0, 0, 0)
AFV2tab.Size = UDim2.new(0, 298, 0, 239)

instantautofarmv2mobile.Name = "instant auto farm v2 mobile"
instantautofarmv2mobile.Parent = AFV2tab
instantautofarmv2mobile.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
instantautofarmv2mobile.BorderColor3 = Color3.fromRGB(0, 0, 0)
instantautofarmv2mobile.BorderSizePixel = 0
instantautofarmv2mobile.Size = UDim2.new(0, 298, 0, 50)
instantautofarmv2mobile.Font = Enum.Font.SourceSansBold
instantautofarmv2mobile.Text = "auto farmv2 instant setup (mobile)"
instantautofarmv2mobile.TextColor3 = Color3.fromRGB(0, 0, 0)
instantautofarmv2mobile.TextSize = 22.000
instantautofarmv2mobile.TextStrokeColor3 = Color3.fromRGB(255, 0, 0)

TextLabel.Parent = AFV2tab
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(-0.00335570471, 0, 0.230125517, 0)
TextLabel.Size = UDim2.new(0, 298, 0, 50)
TextLabel.Font = Enum.Font.SourceSansBold
TextLabel.Text = "auto collect crystals already is  implented"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextSize = 19.000

instantautofarmv2laptop.Name = "instant auto farm v2 laptop"
instantautofarmv2laptop.Parent = AFV2tab
instantautofarmv2laptop.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
instantautofarmv2laptop.BorderColor3 = Color3.fromRGB(0, 0, 0)
instantautofarmv2laptop.BorderSizePixel = 0
instantautofarmv2laptop.Position = UDim2.new(0, 0, 0.476987451, 0)
instantautofarmv2laptop.Size = UDim2.new(0, 298, 0, 50)
instantautofarmv2laptop.Font = Enum.Font.SourceSansBold
instantautofarmv2laptop.Text = "auto farmv2 instant setup (laptop/pc)"
instantautofarmv2laptop.TextColor3 = Color3.fromRGB(0, 0, 0)
instantautofarmv2laptop.TextSize = 22.000
instantautofarmv2laptop.TextStrokeColor3 = Color3.fromRGB(255, 0, 0)

autofarmcollectables.Name = "auto farm collectables"
autofarmcollectables.Parent = mainframe
autofarmcollectables.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
autofarmcollectables.BorderColor3 = Color3.fromRGB(0, 0, 0)
autofarmcollectables.BorderSizePixel = 0
autofarmcollectables.Position = UDim2.new(-0.00343448948, 0, 0.2271339, 0)
autofarmcollectables.Size = UDim2.new(0, 101, 0, 50)
autofarmcollectables.Font = Enum.Font.SourceSansBold
autofarmcollectables.Text = "unfinished"
autofarmcollectables.TextColor3 = Color3.fromRGB(0, 0, 0)
autofarmcollectables.TextSize = 16.000

toggle.Name = "toggle"
toggle.Parent = elementalgroundsgui
toggle.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
toggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
toggle.BorderSizePixel = 0
toggle.Position = UDim2.new(0.483678371, 0, 0.0720164627, 0)
toggle.Size = UDim2.new(0, 28, 0, 28)
toggle.Font = Enum.Font.SourceSansBold
toggle.Text = "X"
toggle.TextColor3 = Color3.fromRGB(0, 0, 0)
toggle.TextSize = 32.000

-- Scripts:

local function ZQKMLIP_fake_script() -- autofarmsetuptab.Script 
	local script = Instance.new('Script', autofarmsetuptab)

	function Click(mouse)
	
		local frame = game.StarterGui.ScreenGui.Frame["AF V2 tab"]
	
		-- Set the initial state
		frame.Visible = true
	
		-- Create a function to toggle visibility
		local function toggleVisibility()
			frame.Visible = not frame.Visible
		end
	
		-- Connect the function to an event (e.g., MouseButtonClick)
		frame.MouseButton1Click:Connect(toggleVisibility)
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(ZQKMLIP_fake_script)()
local function PNQU_fake_script() -- instantautofarmv2mobile.instant respawn 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		_G.toggle = true
	
	
		while _G.toggle do
			wait(0.4)
			local args = {
				[1] = 3
			}
	
			game:GetService("ReplicatedStorage").ClientRemotes.SpawnHandler:FireServer(unpack(args))
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(PNQU_fake_script)()
local function JEKTOF_fake_script() -- instantautofarmv2mobile.lock camara 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		local RunService = game:GetService("RunService")
		local Workspace = game:GetService("Workspace")
		local Players = game:GetService("Players")
	
		local LocalPlayer = Players.LocalPlayer
		local camera = Workspace.CurrentCamera
	
		-- World position to lock the camera at (separated from character)
		local lockedPosition = Vector3.new(0, 0, 0)
	
		-- Function to lock the camera
		local function lockCamera()
			-- Set the camera to Scriptable mode and disable following the character
			camera.CameraSubject = nil
			camera.CameraType = Enum.CameraType.Scriptable
	
			-- Continuous loop on Heartbeat to keep the camera at (0, 0, 0)
			while true do
				if camera then
					camera.CFrame = CFrame.new(lockedPosition)
				end
				RunService.Heartbeat:Wait() -- Ensure this runs every frame
			end
		end
	
		-- Ensure the camera lock function runs on respawn as well
		LocalPlayer.CharacterAdded:Connect(function()
			-- Wait a bit to ensure the character has fully loaded
			wait(2)
	
			-- Lock the camera once the player respawns
			lockCamera()
		end)
	
		-- If the player is already in the game, lock the camera immediately
		if LocalPlayer.Character then
			lockCamera()
		end
	
		print("Camera position locked at world position (0, 0, 0) and will not follow the character, even after respawn.")
	
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(JEKTOF_fake_script)()
local function JGTNU_fake_script() -- instantautofarmv2mobile.launch AF gui 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/NoWayINeededANewFileForE.Gbruh/refs/heads/main/af%20V2%20%5BBeta%5D"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(JGTNU_fake_script)()
local function PZBXI_fake_script() -- instantautofarmv2mobile.remove stupid afk portal 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		local objectsToDestroy = {
			workspace:FindFirstChild("Teleporters"),
			workspace:FindFirstChild("Daily Spin"),
			workspace:FindFirstChild("InteractiveGUI")
		}
	
		for _, obj in ipairs(objectsToDestroy) do
			if obj then
				obj:Destroy()
				print(obj.Name .. " has been destroyed.")
			else
				print("Object not found.")
			end
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(PZBXI_fake_script)()
local function HLYF_fake_script() -- instantautofarmv2mobile.remove forger 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		workspace.Interactables["Forge Information"]:destroy()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(HLYF_fake_script)()
local function UPXYAT_fake_script() -- instantautofarmv2mobile.auto take quest 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
			_G.toggle = true
	
			while _G.toggle do
				wait(0.2)
				for i,v in next, workspace:GetDescendants() do if v.IsA(v,'ProximityPrompt') then fireproximityprompt(v) end end
			end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(UPXYAT_fake_script)()
local function FAYHJ_fake_script() -- instantautofarmv2mobile.auto collect crystals 
	local script = Instance.new('Script', instantautofarmv2mobile)

	function Click(mouse)
	
		local active = false
	
		while true do
			local foundClickDetector = false
	
			-- Iterate through all descendants in the workspace
			for _, instance in ipairs(workspace:GetDescendants()) do
				-- Check if the instance is a ClickDetector itself
				if instance:IsA("ClickDetector") then
					-- Fire the ClickDetector
					fireclickdetector(instance)
					foundClickDetector = true
				end
			end
	
			-- Update the active flag based on whether any ClickDetector was found
			if foundClickDetector then
				active = true
			else
				if active then
					active = false
					print("No ClickDetector found. Stopping.")
				end
				wait(2.5) -- Delay before checking again when inactive
			end
	
			-- If active, add a slight delay to control the firing rate
			if active then
				wait(0.7) -- Adjust this delay for desired firing speed
			end
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(FAYHJ_fake_script)()
local function UTVFZ_fake_script() -- instantautofarmv2laptop.instant respawn 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		_G.toggle = true
	
	
		while _G.toggle do
			wait(0.4)
			local args = {
				[1] = 3
			}
	
			game:GetService("ReplicatedStorage").ClientRemotes.SpawnHandler:FireServer(unpack(args))
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(UTVFZ_fake_script)()
local function UUJB_fake_script() -- instantautofarmv2laptop.launch AF gui 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/NoWayINeededANewFileForE.Gbruh/refs/heads/main/af%20V2%20%5BBeta%5D"))()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(UUJB_fake_script)()
local function COMX_fake_script() -- instantautofarmv2laptop.remove stupid afk portal 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		local objectsToDestroy = {
			workspace:FindFirstChild("Teleporters"),
			workspace:FindFirstChild("Daily Spin"),
			workspace:FindFirstChild("InteractiveGUI")
		}
	
		for _, obj in ipairs(objectsToDestroy) do
			if obj then
				obj:Destroy()
				print(obj.Name .. " has been destroyed.")
			else
				print("Object not found.")
			end
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(COMX_fake_script)()
local function XCGU_fake_script() -- instantautofarmv2laptop.remove forger 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		workspace.Interactables["Forge Information"]:destroy()
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(XCGU_fake_script)()
local function MGIIW_fake_script() -- instantautofarmv2laptop.auto take quest 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
			_G.toggle = true
	
			while _G.toggle do
				wait(0.2)
				for i,v in next, workspace:GetDescendants() do if v.IsA(v,'ProximityPrompt') then fireproximityprompt(v) end end
			end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(MGIIW_fake_script)()
local function EHRLMOR_fake_script() -- instantautofarmv2laptop.auto collect crystals 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		local active = false
	
		while true do
			local foundClickDetector = false
	
			-- Iterate through all descendants in the workspace
			for _, instance in ipairs(workspace:GetDescendants()) do
				-- Check if the instance is a ClickDetector itself
				if instance:IsA("ClickDetector") then
					-- Fire the ClickDetector
					fireclickdetector(instance)
					foundClickDetector = true
				end
			end
	
			-- Update the active flag based on whether any ClickDetector was found
			if foundClickDetector then
				active = true
			else
				if active then
					active = false
					print("No ClickDetector found. Stopping.")
				end
				wait(2.5) -- Delay before checking again when inactive
			end
	
			-- If active, add a slight delay to control the firing rate
			if active then
				wait(0.7) -- Adjust this delay for desired firing speed
			end
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(EHRLMOR_fake_script)()
local function WKRSLGK_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(WKRSLGK_fake_script)()
local function MRRWEBC_fake_script() -- instantautofarmv2laptop.auto take quest 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Reference to necessary services
		local player = game:GetService("Players").LocalPlayer
		local replicatedStorage = game:GetService("ReplicatedStorage")
		local dialogueHandler = replicatedStorage.ClientRemotes.DialogueHandler
		local gameUI = player.PlayerGui:WaitForChild("GameUI")
	
		-- Function to fire the 1, 1, 1 pattern with a 0.7-second delay
		local function fireRemotes111()
			local args1 = { [1] = 1 }
			dialogueHandler:FireServer(unpack(args1))
			wait(0.7)
	
			local args2 = { [1] = 1 }
			dialogueHandler:FireServer(unpack(args2))
			wait(0.7)
	
			local args3 = { [1] = 1 }
			dialogueHandler:FireServer(unpack(args3))
			wait(0.7)
		end
	
		-- Function to fire the 2, 1, 1 pattern with a 0.7-second delay
		local function fireRemotes211()
			local args1 = { [1] = 2 }
			dialogueHandler:FireServer(unpack(args1))
			wait(0.7)
	
			local args2 = { [1] = 1 }
			dialogueHandler:FireServer(unpack(args2))
			wait(0.7)
	
			local args3 = { [1] = 1 }
			dialogueHandler:FireServer(unpack(args3))
			wait(0.7)
		end
	
		-- Function to check conditions and fire remotes
		local function checkAndFireRemotes()
			local dialogue = gameUI.Dialogue
			local quests = gameUI.Quests
			local questHolder = quests:FindFirstChild("QuestHolder")
			local noneText = questHolder and questHolder:FindFirstChild("NoneText")
			local progress = quests.InformationFrame.ScrollingFrame:FindFirstChild("QuestPartProgress") and
				quests.InformationFrame.ScrollingFrame.QuestPartProgress:FindFirstChild("Progress")
	
			-- Fire the 1, 1, 1 pattern if CurrentlySpeaking is true and NoneText.Visible is true
			if dialogue.CurrentlySpeaking.Value == true and noneText and noneText.Visible == true then
				print("CurrentlySpeaking is true and NoneText is visible. Firing 1, 1, 1 remotes...")
				fireRemotes111()
			end
	
			-- Fire the 2, 1, 1 pattern if Progress exists and its text equals "4/4"
			if dialogue.CurrentlySpeaking.Value == true and progress and progress.Text == "4/4" then
				print("Progress is 4/4. Firing 2, 1, 1 remotes...")
				fireRemotes211()
			end
		end
	
		-- Continuously check conditions while the script is active
		while true do
			checkAndFireRemotes()
			wait(1) -- Delay to avoid unnecessary checks
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(MRRWEBC_fake_script)()
local function MYCERO_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(MYCERO_fake_script)()
local function CPJCC_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(CPJCC_fake_script)()
local function XPJZII_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(XPJZII_fake_script)()
local function MGKAHIN_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(MGKAHIN_fake_script)()
local function THPMIG_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(THPMIG_fake_script)()
local function TUOHQW_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(TUOHQW_fake_script)()
local function HCZMCBO_fake_script() -- instantautofarmv2laptop.auto switch tool 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		-- Get the player
		local player = game.Players.LocalPlayer
	
		-- Variable to track the equip loop coroutine
		local loopCoroutine = nil
	
		-- Table to track tools already used in the current cycle
		local usedTools = {}
	
		-- Flag to determine if the character is active (alive and visible)
		local isActive = false
	
		-- Variable to store the last equipped tool to prevent switching to the same tool twice in a row
		local lastEquippedTool = nil
	
		-- Function to set character visibility and update the active state
		local function setCharacterVisibility(isVisible)
			local character = player.Character or player.CharacterAdded:Wait()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") and part.Transparency ~= 1 then
					part.Transparency = isVisible and 0 or 1
				end
			end
	
			if isVisible then
				print("Character became visible. Waiting 3 seconds before resuming...")
				wait(3) -- Wait 3 seconds before resuming activity
				isActive = true -- Update active state to true
			else
				isActive = false -- Update active state to false
			end
		end
	
		-- Function to unequip all tools
		local function unequipAllTools()
			local character = player.Character or player.CharacterAdded:Wait()
			local backpack = player:WaitForChild("Backpack")
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					item.Parent = backpack -- Move tool back to the backpack
				end
			end
		end
	
		-- Function to ensure only one tool is equipped
		local function enforceSingleToolEquipped()
			local character = player.Character or player.CharacterAdded:Wait()
			local toolsEquipped = {}
	
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Tool") then
					table.insert(toolsEquipped, item)
				end
			end
	
			-- If more than one tool is equipped, unequip all
			if #toolsEquipped > 1 then
				print("Multiple tools equipped! Unequipping all tools.")
				unequipAllTools()
			end
		end
	
		-- Function to get all tools in the backpack and hotbar
		local function getToolsInHotbarAndBackpack(backpack)
			local tools = backpack:GetChildren()
			local toolList = {}
	
			-- Assume Tool 1 is the first tool in the hotbar
			-- and that we proceed through all other tools
			for _, tool in pairs(tools) do
				if tool:IsA("Tool") then
					table.insert(toolList, tool)
				end
			end
	
			return toolList
		end
	
		-- Function to equip a tool from the cycle
		local function equipToolFromCycle(toolList, toolIndex)
			if not isActive then return end -- Stop if the character is not active
	
			local tool = toolList[toolIndex]
	
			if tool then
				-- Enforce single-tool policy before equipping
				enforceSingleToolEquipped()
	
				tool.Parent = player.Character -- Equip the tool
				print("Equipped: " .. tool.Name)
	
				-- Mark this tool as used and store it as the last equipped tool
				lastEquippedTool = tool.Name
	
				wait(1) -- Reduced delay for faster switching
				tool.Parent = player.Backpack -- Unequip the tool after switching
			else
				print("No tool at this index!")
			end
		end
	
		-- Function to start the equip loop from Tool 1 in the hotbar and cycle through all tools
		local function startEquipLoop()
			-- Stop the previous loop if it exists
			if loopCoroutine and coroutine.status(loopCoroutine) ~= "dead" then
				coroutine.close(loopCoroutine) -- Destroy the old coroutine
			end
	
			-- Create a new loop coroutine
			loopCoroutine = coroutine.create(function()
				local backpack = player:WaitForChild("Backpack")
				local toolList = getToolsInHotbarAndBackpack(backpack)
	
				-- Start from the first tool in the hotbar
				local toolIndex = 1
	
				while true do
					equipToolFromCycle(toolList, toolIndex)
	
					-- Move to the next tool in the list
					toolIndex = toolIndex + 1
					if toolIndex > #toolList then
						toolIndex = 1 -- Reset the cycle back to the first tool
					end
	
					wait(0.5) -- Shorter delay between equipping tools for faster switching
				end
			end)
	
			-- Start the new coroutine
			coroutine.resume(loopCoroutine)
		end
	
		-- Handle respawn and initialize the script
		local function onCharacterAdded(character)
			-- Set the character as visible and active after 3 seconds
			setCharacterVisibility(true)
	
			-- Wait for the character to fully load
			wait(2) -- Adjust as needed for loading time
	
			-- Start the equip loop
			startEquipLoop()
		end
	
		-- Handle character death (set inactive and stop equipping tools)
		local function onCharacterRemoving()
			setCharacterVisibility(false) -- Mark as inactive
			unequipAllTools() -- Unequip all tools immediately
		end
	
		-- Connect to the CharacterAdded and CharacterRemoving events
		player.CharacterAdded:Connect(onCharacterAdded)
		player.CharacterRemoving:Connect(onCharacterRemoving)
	
		-- Handle initial spawn
		if player.Character then
			onCharacterAdded(player.Character)
		end
	
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(HCZMCBO_fake_script)()
local function JOMUX_fake_script() -- instantautofarmv2laptop.remove trees 
	local script = Instance.new('Script', instantautofarmv2laptop)

	function Click(mouse)
	
		game.workspace.Map["Inner Trees"]:destroy()
	end
	
	
	script.Parent.MouseButton1Down:connect(Click)
end
coroutine.wrap(JOMUX_fake_script)()
local function ZJVRTB_fake_script() -- mainframe.LocalScript 
	local script = Instance.new('LocalScript', mainframe)

	local dragger = {}; 
	local resizer = {};
	
	do
		local mouse = game:GetService("Players").LocalPlayer:GetMouse();
		local inputService = game:GetService('UserInputService');
		local heartbeat = game:GetService("RunService").Heartbeat;
		-- // credits to Ririchi / Inori for this cute drag function :)
		function dragger.new(frame)
			local s, event = pcall(function()
				return frame.MouseEnter
			end)
	
			if s then
				frame.Active = true;
	
				event:connect(function()
					local input = frame.InputBegan:connect(function(key)
						if key.UserInputType == Enum.UserInputType.MouseButton1 then
							local objectPosition = Vector2.new(mouse.X - frame.AbsolutePosition.X, mouse.Y - frame.AbsolutePosition.Y);
							while heartbeat:wait() and inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
								frame:TweenPosition(UDim2.new(0, mouse.X - objectPosition.X + (frame.Size.X.Offset * frame.AnchorPoint.X), 0, mouse.Y - objectPosition.Y + (frame.Size.Y.Offset * frame.AnchorPoint.Y)), 'Out', 'Quad', 0.1, true);
							end
						end
					end)
	
					local leave;
					leave = frame.MouseLeave:connect(function()
						input:disconnect();
						leave:disconnect();
					end)
				end)
			end
		end
	
		function resizer.new(p, s)
			p:GetPropertyChangedSignal('AbsoluteSize'):connect(function()
				s.Size = UDim2.new(s.Size.X.Scale, s.Size.X.Offset, s.Size.Y.Scale, p.AbsoluteSize.Y);
			end)
		end
	end
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(ZJVRTB_fake_script)()
local function ZLRCYLS_fake_script() -- toggle.LocalScript 
	local script = Instance.new('LocalScript', toggle)

	local dragger = {}; 
	local resizer = {};
	
	do
		local mouse = game:GetService("Players").LocalPlayer:GetMouse();
		local inputService = game:GetService('UserInputService');
		local heartbeat = game:GetService("RunService").Heartbeat;
		-- // credits to Ririchi / Inori for this cute drag function :)
		function dragger.new(frame)
			local s, event = pcall(function()
				return frame.MouseEnter
			end)
	
			if s then
				frame.Active = true;
	
				event:connect(function()
					local input = frame.InputBegan:connect(function(key)
						if key.UserInputType == Enum.UserInputType.MouseButton1 then
							local objectPosition = Vector2.new(mouse.X - frame.AbsolutePosition.X, mouse.Y - frame.AbsolutePosition.Y);
							while heartbeat:wait() and inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
								frame:TweenPosition(UDim2.new(0, mouse.X - objectPosition.X + (frame.Size.X.Offset * frame.AnchorPoint.X), 0, mouse.Y - objectPosition.Y + (frame.Size.Y.Offset * frame.AnchorPoint.Y)), 'Out', 'Quad', 0.1, true);
							end
						end
					end)
	
					local leave;
					leave = frame.MouseLeave:connect(function()
						input:disconnect();
						leave:disconnect();
					end)
				end)
			end
		end
	
		function resizer.new(p, s)
			p:GetPropertyChangedSignal('AbsoluteSize'):connect(function()
				s.Size = UDim2.new(s.Size.X.Scale, s.Size.X.Offset, s.Size.Y.Scale, p.AbsoluteSize.Y);
			end)
		end
	end
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(ZLRCYLS_fake_script)()
local function FYPL_fake_script() -- toggle.LocalScript 
	local script = Instance.new('LocalScript', toggle)

	local back = script.Parent.Parent["main frame"]
	local con = script.Parent.Parent["main frame"]
	
	local window = {
		count = 0;
		toggles = {},
		closed = false;
	}
	script.Parent.MouseButton1Click:connect(function()
		window.closed = not window.closed
		script.Parent.Text = (window.closed and "+" or "-")
		if script.Parent.Text == "+" then
			back:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
			con:TweenSize(UDim2.new(0, 190,0, 0), "Out", "Sine", 0.5)
			wait(0.1) do
				con.Visible = false
			end
		else
			back:TweenSize(UDim2.new(0, 399,0, 239), "Out", "Sine", 0.5)
			con:TweenSize(UDim2.new(0, 399,0, 239), "Out", "Sine", 0.5)
			wait(0.2) do
				con.Visible = true
			end
		end
	
	end)
end
coroutine.wrap(FYPL_fake_script)()
